interface DbField{
// DbField need support composeTypeName, however it can't constraint on metaclass
// and for standard data types, it will translate to each database typename with its adapter
// only db owned types need implement this interface, i.e. JSONB in PG
//    metaclass{
//        fun composeTypeName() as string {
//        }
//    }
}


class VarChar from String{
    metaclass{
        maxLength as int
        fun new(maxLength as int){
            this.maxLength = maxLength
        }
    }
}

class BigInt from Boxer<long>{
}

native class QueryResult<T> with Iterator<T>{
    override hasNext() as boolean native "org.siphonlab.ago.runtime.rdb.QueryResult.hasNext"
    override next() as T native "org.siphonlab.ago.runtime.rdb.QueryResult.next"
}

// everything stored in db, but only extends Table can have getRowById and table functions
// and if GC enabled, if not extends Table the data will be clean by GC
class Table<T>{
    metaclass{
        fun of(id as long) as T native "org.siphonlab.ago.runtime.rdb.Table.getRowById";

        fun fetchAll() as QueryResult<User> native "org.siphonlab.ago.runtime.rdb.Table.fetchAll"

    }
}


class User from Table<User> {
    metaclass{
        class Name from VarChar::(100)
        class Address from VarChar::(200)
        class Age from BigInt

        // fun findByName(name as User.Name) as Iterable<User> native "org.siphonlab.ago.rdb.Table.findBy"
    }
    name as Name;
    address as Address;
    age as Age
}

fun main(){
    var u = new User() with {
        .name = "Tom";
        .address = "liberation street 222";
        .age = 20;
    }

//    // next time we can load from existed data
//    var u = User.of(1)

    Trace.print(u.name)
    Trace.print(u.age)
}

enum HttpMethod{
    Get, Post, Put, Delete, Patch, Options, Head
}

native trait RestService<R> for Function0<R>{
    metaclass{
        httpMethod as HttpMethod
        path as string
        fun new#GET(path as string){
            this.httpMethod = HttpMethod.Get
            this.path = path
        }
        fun new#method(httpMethod as HttpMethod, path as string){
            this.httpMethod = httpMethod
            this.path = path
        }
    }
    // JSON
    fun payload<T>() as T native "org.siphonlab.ago.web.RestfulService.payload"
}

fun listUsers() as QueryResult<User> with RestService<Iterator<User>>::('/list_users'){
    return User.fetchAll()
}

fun getUserById(id as long) as User with RestService<User>::('/user/{id}'){
    return User.of(id)
}

fun create_user() as User with RestService<User>::(HttpMethod.Post, '/create_user'){
    var input = fun.this.payload<User>()        // decoded json, to User
    var u = new User()
    u o= input
    return u
}

fun update_user(id as long) as User with RestService<User>::(HttpMethod.Put, '/update_user/{id}'){
    var input = fun.this.payload<User>();
    var u = User.of(id)
    u o= input
    return u;
}