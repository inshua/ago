fun add(a as int, b as int) as int{
    return a + b
}

fun add2(a as int, b as int) as int{
    return a + b + a + b
}

class C{
    metaclass{
        metaValue as int = 20;
        fun multi(a as int, b as int) as int{
            return metaValue * a * b;
        }
    }
    i as int
    fun new(i as int){
        this.i = i;
    }
    fun add(a as int, b as int) as int{
        return this.i + a + b
    }

    fun add2(a as int, b as int) as int{
        return i + a + b + a + b
    }

    fun wrapMulti() like add{
        var f like add = multi;
        return f;
    }
}

fun test(op like add, a as int, b as int){
    Trace.print(op(a, b))
}

fun main(){
    test(add, 1, 2)     // 3
    test(add2, 1, 2)    // 6

    var c = new C(100);
    test(c.add, 1, 2)
    test(c.add2, 1, 2)

    var f like add = c.add2
    Trace.print(f(3, 4))

    test(f, 10, 20);

//    test((fun f1(a as int, b as int) as int{return c.add(a, b) + 1000}), 30, 40)       //TODO

    f = C.multi;
    Trace.print(f(5, 6))    // 20 * 5 * 6 = 600
    test(C.multi, 5, 6)     // 600

    f = c.wrapMulti();
    Trace.print(f(7, 8))
}